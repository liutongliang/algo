# 排序算法

[toc]

## 一、选择排序

### 	1、过程

​		arr[0 ~ N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。

​		arr[1 ~ N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。

​		arr[2 ~ N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。

​		...

​		arr[N-1 ~ N-1]范围上，找到最小值所在的位置，然后把最小值交换到N-1位置。

### 	2、复杂度

#### 		（1）时间复杂度

​		很明显，如果arr的长度为N，每一步常数操作的数量，如同等差数列一般，N，N-1，N-2 ... 1

​		所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、 c都是常数)

​		所以选择排序的时间复杂度为O(N^2)。

#### 		（2）额外空间复杂度

​		很明显，操作过程中只使用了有限个额外的内存空间，所以空间复杂度为O(1)

### 	3、代码
```java
    public static void selectionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 0 ~ n-1
        // 1 ~ n-1
        // 2 ~
        for (int i = 0; i < arr.length - 1; i++) { // 0 ~ n-2 剩下一个数时不用比较
            // 最小值在哪个位置上 i ~ n-1
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) { // i ~ n-1 上找最小值的下标
                if (arr[minIndex] > arr[j]) {
                    minIndex = j;
                }
            }
            swap(arr, i, minIndex);
        }
    }
```

## 二、冒泡排序

### 1、过程

​		在arr[0 ~ N-1]范围上：

​		arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置...arr[N-2]和arr[N-1]，谁大谁来到N-1位置

​		在arr[0 ~ N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置

​		在arr[0 ~ N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置

​		...

​		最后在arr[0 ~ 1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置

### 2、复杂度

#### 	（1）时间复杂度

​		很明显，如果arr长度为N，每一步常数操作的数量，如同等差数列一般，N，N-1，N-2 ...1

​		所以，总的常数操作数量 = a*(N^2) + b*N +c (a、b、c都是常数)

​		所以冒泡排序的时间复杂度为O(N^2)。


#### 	（2）额外空间复杂度

​		很明显，在操作过程中只使用了有限个额外的内存空间，所以空间复杂度为O(1)。

### 3、代码

```java
    public static void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 0 ~ n-1
        // 0 ~ n-2
        // 0 ~ n-3
        //...
        // 0 ~ 1
        for (int i = arr.length - 1; i > 0; i--) {
            // 0 ~ i
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    SortUtils.swap(arr, j, j + 1);
                }
            }
        }
    }
```

## 三、插入排序

### 1、过程

​		想让arr[0 ~ 0]上有序，这个范围只有一个数，当然是有序的

​		想让arr[0 ~ 1]上有序，所以从arr[1]开始往前看，如果arr[1] < arr[0]，就交换，否则什么也不做

​		...

​		想让arr[0 ~ i]上有序，所以从arr[i]开始往前看，如果arr[i]这个数不停地向左移动，直到自己不再比左边的数小，停止移动

​		最后一步，想让arr[0 ~ N-1]上有序，arr[N-1]这个数不停地向左移动，直到自己不再比左边的数小，停止移动

### 2、复杂度

#### 	（1）时间复杂度

​				这个算法流程的复杂程度随着数据状况的不同而不同，最好的情况是arr本身就完全有序，最坏的情况是arr完全无序。

​				按照最坏的情况估计，如果arr的长度为N，每一步常数操作的数量如同等差数列一般，1，2，3 ... N

​				所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)

​				所以插入排序的时间复杂度为O(N^2)。

#### 	（2）额外空间复杂度

​				很明显，在操作过程中只使用了有限个额外的内存空间，所以空间复杂度为O(1)。

### 3、代码

```java
    public static void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 0 ~ 0 想有序
        // 0 ~ 1 想有序
        // 0 ~ 2 想有序
        // ...
        // 0 ~ n-1 想有序
        for (int i = 1; i < arr.length; i++) {
            // 0 ~ i 想有序
            for (int j = i - 1; j >= 0 && arr[j + 1] < arr[j]; j--) {
                SortUtils.swap(arr, j, j + 1);
            }
        }
    }
```

